#!/usr/bin/perl -w

#******************************************************************************
# collect shielding tensor from quantum chemistry outputs
#   usage:  gettensor-qchem program basename; rdb file fragments to stdout
#******************************************************************************

use Math::MatrixDecomposition::Eigen;

$program = "$ARGV[0]";
$basename = "$ARGV[1]";
if( $basename eq "header" ){
   printf( "# results from afnmr-orca:\n" );
   printf( "res\tatomname\tresname\txx\txy\txz\tyx\tyy\tyz\tzx\tzy\tzz\tdelta\teta\n" );
   printf( "4N\t8\t8\t10N\t10N\t10N\t10N\t10N\t10N\t10N\t10N\t10N\t10N\t10N\n" );
   exit(0);
}

$_ = $basename; s/.+(\d\d\d)/$1/; $resi = $_;

# get atom and residue names from pqr file:

open (PQR, "<", "$basename". ".pqr") or die "cannot open $basename.pqr";
$iat = 0;
while (<PQR>) {
    next unless m/^ATOM  /; 
    @f = split( ' ', $_ );
	$iat++; $aname[$iat] = $f[2]; $rname[$iat] = $f[3]; $res[$iat] = $f[4];
    $rname[$iat] =~ s/^([ACTGU])[35]$/$1/;  # fix 3',5' ends of nucleic acids
}
close PQR;

# read in the shift data -- this is program-dependent:

if( $program eq "orca" ){
   open (LOG, "<", "$basename" . ".out") or die "cannot open $basename.out";
} elsif( $program eq "qchem" ){
   open (LOG, "<", "$basename" . ".qcout") or die "cannot open $basename.qcout";
   print "opening $basename.qcout\n";
} elsif( $program eq "gaussian" ){
   open (LOG, "<", "$basename" . ".log") or die "cannot open $basename.log";
} else {
   die "program $program not recognized\n";
}


while (<LOG>) {

  $found = 0;
  if( $program eq "orca" ){

    if( m/^ Nucleus /){

       $found = 1;
       $iat = substr($_,9,3) + 1; $elem = substr($_,10,1);
       next if $elem eq "O";  next if $rname[$iat] eq "MOD";
       next if $elem eq "S";
       #  get just the shifts in the "primary residue" (includes previous C):
       next unless $iat<3 or ($res[$iat]==$resi and $aname[$iat] ne "C")  or
                   ($aname[$iat] eq "C" and $res[$iat]==$resi - 1);

       # skip 13 lines:
       <LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;
       <LOG>;<LOG>;<LOG>;

       $_ = <LOG>; @f = split( ' ', $_ );
       $xx = $f[0]; $xy = $f[1]; $xz = $f[2];
       $_ = <LOG>; @f = split( ' ', $_ );
       $yx = $f[0]; $yy = $f[1]; $yz = $f[2];
       $_ = <LOG>; @f = split( ' ', $_ );
       $zx = $f[0]; $zy = $f[1]; $zz = $f[2];
    }

  } elsif ( $program eq "qchem" ){

     if (m/^  -- ATOM/){

       $found = 1;
       @f = split( ' ', $_ ); $iat = $f[3]; $elem = $f[2];
       next if $elem eq "O";  next if $rname[$iat] eq "MOD";
       next if $elem eq "S";
       #  get just the shifts in the "primary residue" (includes previous C):
       next unless $iat<3 or ($res[$iat]==$resi and $aname[$iat] ne "C")  or
                   ($aname[$iat] eq "C" and $res[$iat]==$resi - 1);

       # skip 25 lines:
       <LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;
       <LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;<LOG>;
       <LOG>;<LOG>;<LOG>;<LOG>;<LOG>;

       $_ = <LOG>; @f = split( ' ', $_ );
       $xx = $f[0]; $xy = $f[1]; $xz = $f[2];
       $_ = <LOG>; @f = split( ' ', $_ );
       $yx = $f[0]; $yy = $f[1]; $yz = $f[2];
       $_ = <LOG>; @f = split( ' ', $_ );
       $zx = $f[0]; $zy = $f[1]; $zz = $f[2];
     }

  } elsif ( $program eq "gaussian" ){

     if (m/ Isotropic = /) {

       $found = 1;
       @f = split( ' ', $_ ); $iat = $f[0]; $elem = $f[1];
       next if $elem eq "O";  next if $rname[$iat] eq "MOD";
       next if $elem eq "S";
       #  get just the shifts in the "primary residue" (includes previous C):
       next unless $iat<3 or ($res[$iat]==$resi and $aname[$iat] ne "C")  or
                   ($aname[$iat] eq "C" and $res[$iat]==$resi - 1);

       $_ = <LOG>; @g = split( ' ', $_);
       $xx = $g[1]; $yx = $g[3]; $zx = $g[5];
       $_ = <LOG>; @g = split( ' ', $_);
       $xy = $g[1]; $yy = $g[3]; $zy = $g[5];
       $_ = <LOG>; @g = split( ' ', $_);
       $xz = $g[1]; $yz = $g[3]; $zz = $g[5];
     }

  }

  if( $found ){
       printf "%d\t%s\t%s\t%8.3f\t%8.3f\t%8.3f\t%8.3f\t%8.3f\t%8.3f\t%8.3f\t%8.3f\t%8.3f",
         $res[$iat],$aname[$iat],$rname[$iat],
         $xx,$xy,$xz,$yx,$yy,$yz,$zx,$zy,$zz;

       # explicitly balance the matrix:
       $xy = 0.5 * ($xy + $yx);  $yx = $xy;
       $xz = 0.5 * ($xz + $zx);  $zx = $xz;
       $yz = 0.5 * ($yz + $zy);  $zy = $yz;

       # get 1/3 of the trace == isotropic shielding:
       $siso = ( $xx + $yy + $zz )/3.0;

       # get the eigenvalues:
       @shielding = ($xx,$xy,$xz,$yx,$yy,$yz,$zx,$zy,$zz);

       $eigen = Math::MatrixDecomposition::Eigen->new ( \@shielding );
       $eigen->sort( 'asc' );

       @eigv = $eigen->values;
       # printf "%8.3f  %8.3f  %8.3f\n", $eigv[0], $eigv[1], $eigv[2];
       # $first = $eigen->vector (0);
       # printf "%8.3f  %8.3f  %8.3f\n", @$first;

       # Analyze the principal components:

       if( abs($siso - $eigv[0]) > abs($siso - $eigv[2]) ){
          $delta  = $siso - $eigv[0];  $eta = ($eigv[2]-$eigv[1])/$delta;
       } else {
          $delta  = $siso - $eigv[2];  $eta = ($eigv[0]-$eigv[1])/$delta;
       }
       # line below uses the solution convention for delta:
       $delta = -1.5 * $delta;
       # $span = $eigv[2] - $eigv[0];

       printf "\t%8.3f\t%8.3f\n", $delta, $eta;
  }

}
close LOG;
